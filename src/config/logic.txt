0) Inputs & global rules
User input: topic, hiddenThemePhrase, topicWords[], difficulty.
Constraints:
Grid size (e.g., 12×12), 180° rotational symmetry.
Token regex: ^[A-Z0-9_]+$ (uppercase, no spaces).
American rules: every letter checked; no 2-letter entries; no isolated blocks; reasonable block count (target ~15–22 for 12×12, tune).

1) Normalize & classify (local)
Uppercase + strip spaces/dashes for all inputs.
Theme tokens: use AI once to split hiddenThemePhrase into ordered tokens.
Topic words: sanitized list; keep a master exclude set (tokens + topic words) so nothing echoes later.
Sort both lists alphabetically for determinism (you can also keep original order as metadata).
Artifacts
foundation.meta (topic, difficulty, gridMaxLetters, timestamps)
foundation.theme.tokens[]
foundation.topic.words[]
excludeSet[]

2) Theme containers (embed tokens in longer real words; local + dictionary)
For each token T (len t):
For lengths L ∈ [t+2 … min(t+6, gridMax)]:
Pull dictionary candidates (OneLook/Datamuse or your local list) for length L.
Filter word.includes(T), sanitize, dedupe.
Rank (provider score, medical boost, frequency, simple topic overlap).
Keep top 10–20 per token.
Artifacts
theme_containers.json: { [token]: string[] } (sorted)

3) Candidate pools by length (dictionary-first, no AI)
Build per-length pools for all non-theme slots you expect:
Query OneLook/Datamuse with ml=<topic>&topics=medical&sp=< ?×L >&max=300.
Cache by (topic, length).
Sanitize, dedupe, rank (provider score, medical boost, frequency).
Keep top 10–30 per length.
Optional tiers:
medical[L] (primary)
general[L] (fallback fillers, unlocked only when needed)
Artifacts
pools.json: { [length]: string[] } (and optionally { tier: "medical"|"general" })

4) Solver inputs (no pre-pairing; solver chooses)
Slots: parse the grid layout (with blocks) into across/down slots:

type Slot = {
  id: string; dir: "across"|"down";
  row: number; col: number; length: number;
  crosses: Array<{ otherId: string; atThis: number; atOther: number }>;
  isTheme: boolean; themeToken?: string; // if this slot must embed a token
};

Domains at start:
Theme slots: domain = themeContainers[token] ∩ pattern.
Others: domain = poolsByLen[length] ∩ pattern.
pattern = fixed letters already placed; use positional indexes for fast intersection:
posIndex[L][i][ch] -> Set<string>.

5) Solver strategy (CSP: backtracking + forward checking)
MRV (Minimum Remaining Values): pick the slot with the smallest domain.
Tie-breakers: most crossings → longer length → alphabetical.
LCV ordering for candidates: pick the word that eliminates the fewest options for neighbors (approximate by counting survivors).
Forward checking: when you place a word, write letters and immediately prune intersecting domains; if any becomes empty → backtrack.
Determinism: everything sorted; when equal, fall back to alphabetical.
Soft preferences (optional):
If you have “buddy” hints (e.g., ANTIBODIES prefers ANTIGENIC), use them only to prioritize candidate order—never to force matches.
Fallback policy:
Start with medical pools.
If a slot’s domain empties or backtracks exceed a threshold:
unlock general tier for that slot’s length and continue.
Output

type SolverOutput = {
  ok: boolean;
  assignments: Map<slotId, word>;
  usedWords: Set<string>;
  stats: { steps: number; backtracks: number; durationMs: number; fillersUsed: number };
};

6) Optional online pattern checks (sparingly)
If you want an extra safety net during tricky crosses:
Use Datamuse pattern queries (sp=C?4CO?NT&topics=medical) only when a domain is nearly empty and you need to expand choices.
Don’t rely on APIs for tokens like CD4COUNT (digits/underscores are spotty); treat those as forced from your internal lexicon.

7) Clue generation (post-solve; AI is fine here)
For each final answer, ask for multiple clue styles in strict JSON:
Straight (definition)
Educational (1-line prevention/diagnostics context)
Tricky (harder surface, still fair)
Map to difficulty:
Easy: straight/educational, no jargon, no stigma.
Medium: mix straight + mild wordplay.
Hard: trickier; still medically accurate.
Keep red-lines (no advice, no stigma).
Artifacts
clues.json: { answer: { straight: "...", educational: "...", tricky: "..." } }

8) Orchestration order (single run)
Normalize inputs; build excludeSet.
Theme tokens ← AI (strict JSON).
Theme containers ← dictionary filters (save).
Pools by length ← dictionary (save).
Grid model (slots, symmetry, rules).
Solver:
Seed theme domains from themeContainers.
Seed others from poolsByLen.
Run MRV/LCV + forward checking with fallback tiers.
Clues ← AI (post-solve).
Artifacts:
foundation.json (meta, theme, pools summary, assignments)
pools.json, theme_containers.json, clues.json, solver_stats.json
Logs: choices, backtracks, when fillers unlocked, any unsatisfied constraints.

9) Determinism switches
Sort everything (tokens, containers, pools, slot ordering).
Make candidate ordering stable (score → alpha).
If you add any randomness, seed it and log the seed in solver_stats.json.

10) Prompts (only two)
A) Theme tokens (extract):
Input (JSON body) with topic, hiddenThemePhrase, maxLettersPerToken, maxTokens, regex constraint.
Output: { "hiddenWordsOrdered": ["KNOW","YOUR","STATUS"] }.

B) Clue generation (post-solve):
Input: { answer, topic, difficulty, constraints }
Output: { "straight": "...", "educational": "...", "tricky": "..." }.
(If you still want selection-only for special cases, keep the tiny prompt that picks one from a provided candidates array—strict JSON { "suggestion": "..." }.)

Folders and files
/src/config/
difficulty.js — Maps difficulty → knobs (target block count range, max word length, medical-first bias, backtrack limits, when to unlock “general” filler, etc.).
rules.js — Universal rules (US-style, symmetry=180°, min entry length=3, token regex, allowed grid sizes).
/src/data/ (generated)
pools.json — Per-length candidate pools (medical/general tiers).
theme_containers.json (optional) — Longer real words that contain each theme token.
foundation.json — Run metadata + inputs + pool summaries.
solver_stats.json — Steps, backtracks, timings, tier unlocks, seed used.
grid_final.json — Final filled grid + numbering + entries.
/src/dicts/
wordlist-medical.txt (optional local lexicon)
wordlist-general.txt (optional local fallback)
/src/utils/
normalize.js — Uppercasing, token regex, dedupe helpers.
rng.js — Seeded RNG (for any randomized tie-breaks; default off for determinism).
logger.js — Structured logs + step tracing.
persist.js — Writers for artifacts, pretty-print helpers.
/src/dictionary/
indexes.js — Builds fast in-memory indexes:
byLen[L] arrays (tiered: medical/general)
posIndex[L][i][ch] -> Set(word) for O(1)-ish pattern intersects
Optional “frequency/score” map for ranking.
patternLookup.js — candidatesForPattern(L, fixedLetters, tierPolicy) using the indexes (and optional Datamuse/OneLook as a rare fallback).
/src/theme/
containers.js (optional) — Build/validate container candidates for each theme token from your pools/dicts.
placement.js — Strategies to place theme containers in the grid (choose slots/coords that respect symmetry and leave fillable neighborhoods).
/src/grid/
grdModel.js — Grid data structure + symmetry helpers
place letter / place block (and mirror)
validate symmetry, no 2-letter slots, connectivity
slots.js — Extracts Across/Down slots from the current grid; computes crossings.
numbering.js — Assigns crossword numbers; builds acrossEntries/downEntries metadata.
/src/solver/
domains.js — Initializes and updates slot domains from pools + fixed letters; tier policy (medical-first, unlock general on demand).
heuristics.js — MRV (smallest domain), tie-breakers (most crossings, longer first), LCV (least-constraining value scoring), candidate ordering (score → alpha).
propagate.js — Forward checking: when a word is placed, prune intersecting slot domains; detect domain wipeouts.
backtracker.js — Core CSP search:
choose next slot (MRV)
iterate ordered candidates (LCV)
place → propagate → recurse; on failure, restore snapshot
respects time/backtrack limits from difficulty
layoutGenerator.js — Block layout strategies:
Start from a seed (theme placements) and generate symmetric block patterns within target count
Or dynamic “rescue” blocks: when repeated dead-ends, propose adding a symmetric block pair that doesn’t create 2-letter slots and stays within block budget
planner.js — Orchestrates the whole run:
load inputs (tokens, pools, difficulty)
choose/validate theme containers
generate or refine a symmetric layout
extract slots, init domains
run backtracker with tier policy
if fail: adjust layout or widen tiers; retry with limits
/src/qa/
validateGrid.js — Final checks: all entries length≥3; every entry exists in dicts (or whitelisted proper names), fully checked letters, symmetry, block count in range.
scoreGrid.js — Qulity scoring (theme integration, % medical, obscurity penalties, unchecked/unchecked = 0, long entries bonus, etc.).
/src/clueing/
cluePrompt.js — Your AI prompt builder for clues (straight/educational/tricky).
clueWriter.js — Calls the model and attaches clues to numbered entries; difficulty mapping.
/src/index.js
The orchestrator you already have: builds pools/tokens, then calls planner.solve() and writes artifacts, then clueWriter.
How it works (mechanics)
Prep
Normalize inputs; load difficulty knobs.
Load pools (medical/general) and build indexes (byLen + posIndex).
Theme placement
If using containers: pick top N per token; for each candidate layout:
place the container, mirror letters by symmetry rules
reject layouts that create 2-letter slots or disconnect the grid
Layout generation
Either start with a template (precomputed symmetric masks by block count), or grow blocks dynamically:
Keep block count in the difficulty’s target range
Each block mirrors across center (180°)
Every fillable cell should be checked by both an across and a down slot where possible
Slot extraction & domain init
Extract all slots (Across/Down), crossings metadata
For each slot: build initial domain using patternLookup on the medical tier
pattern = letters already fixed from crossings (if theme placed)
if domain empty → immediate fail of this layout (or unlock general tier if policy allows)
Search (CSP backtracking)
Pick next slot with MRV
Order slot’s candidates with LCV (simulate letter propagation to see how many options neighbors keep; cheaper approximation: sum of neighbor domain sizes after placement)
Try each candidate:
write letters to grid
propagate constraints; if any neighbor domain → empty, backtrack
recurse
Stop when all slots assigned or you hit difficulty’s time/backtrack budget
If repeated failures cluster in one region, optionally call layoutGenerator to add a symmetric block pair that breaks a stubborn long slot (only if within block budget), then restart domains
Tier policy (medical → general)
Start with medical tier only
If a specific slot is starved (domain size < k) or overall backtracks exceed a threshold, merge general[L] into that slot’s domain (or globally for that length)
Track how often/where you unlocked filler in solver_stats
Finish & QA
Validate grid (rules + dictionary coverage)
Score grid (for your own ranking/selection if you tried multiple layouts)
Number entries; save grid_final.json and solver_stats.json

Cluing
Buid across/down entry lists; call clue prompt per difficulty
Save clues.json, attach to foundation
Difficulty levers (examples)
Block count: Easy 20–24; Medium 17–21; Hard 14–18 (12×12 tune)
Max word length: Hard allows more 8–10s; Easy prefers 3–7
Tier unlock: Easy unlock general early; Hard keep medical longer
Backtrack cap: Easy higher cap + allow rescue blocks; Hard lower cap, fewer rescues
LCV depth: Harder puzzles compute fuller LCV (more accurate; slower)